; Сапрыкин Дмитрий
; Программа-калькулятор, позволяющая пользователю выполнять четыре основных арифметических действия над целыми числами, укладывающимися в 8-байтовый диапазон.
.model small	; один сегмент кода, данных и стека
.stack 100h		; отвести под стек 256 байт
.data			; начало сегмента данных
start_menu	db 'Select operation:', 10, '1 - Sum', 10, '2 - Difference', 10, '3 - Multiply', 10, '4 - Divide', 10, '5 - Exit', 10, '$'; меню пользователя
first_num	dw 4 dup(0) 	; первое вводимое число
second_num	dw 4 dup(0) 	; второе вводимое число
first_num_message	db 'First number:', 10, '$' 	; строка перед вводом первого числа	в консоли
second_num_message	db 'Second number:', 10, '$'	; строка перед вводом второго числа в консоли
input_num	db 21, 0, 21 dup(?)	; буфер для считывания числа из консоли
carriage_return	db 10, '$'		; возврат каретки
error_symbol_string db 'Invalid characters', 10, '$'	 		 ; строка ошибки при вводе некорректного символа
error_overflow_string db 'Overflow has occurred', 10, '$'		 ; строка ошибки при переполнении
error_divide0_string db 'Error! Attempt to divide by 0', 10, '$' ; строка ошибки при попытке деления на 0
exit_program_string db 'Exiting...', 10, '$'					 ; строка завершения программы
ten dd 10		; множитель для увелечения разрядности числа
added_num dw (?); цифра, которая добавляется при накапливаемости числа
zero dd 0 ; константа 0 для удобства
unit dd 1 ; константа 1 для удобства
help_num dw 4 dup(?)        ; вспомогательная переменная, хранящая остаток делимого
zero_number dw 4 dup(0)     ; константа для случаев умножения на 0
result db 'Result: $'   ; результат операции
num_of_operation db 1 dup(?); номер выбранной операции
count_negNumbers db 0		; кол-во введенных отрицательных чисел
.code			; начало сегмента кода
.386

; макрос для считывания от пользователя номера операции
check_operation MACRO
	mov ah, 1h
	int 21h ; ввод символа с клавиатуры

	mov ah, 9h
	mov dx, offset carriage_return
	int 21h ; вывод переноса

	xor ah, ah
	
	cmp ax, '1' ; сумма
	mov [num_of_operation], 0b ; устанавливаем номер операции
	je sum
	
	cmp ax, '2' ; разность
	mov [num_of_operation], 1b ; устанавливаем номер операции
	je diff
	
	cmp ax, '3' ; произведение
	mov [num_of_operation], 10b ; устанавливаем номер операции
	je multi
	
	cmp ax, '4' ; деление
	mov [num_of_operation], 11b ; устанавливаем номер операции
	je divide
	
	cmp ax, '5' ; выход из программы
	je exit_program
	jmp error_symbol ; ошибка "Неверный символ"
ENDM

; макрос для подготовки считывания операндов операции
input_nums MACRO

	mov ah, 9h
	mov dx, offset first_num_message 
	int 21h ; вывод подсказки для пользователя
	
	push offset input_num
	push offset first_num
	call convert_StringToInt ; передаем в функцию "конвертация строки в число" два параметра: 1) адрес начала буфера строки 2) адрес начала первого числа
	
	xor bx, bx
	
	mov ah, 9h 
	mov dx, offset second_num_message
	int 21h ; вывод подсказки для пользователя
	
	push offset input_num
	push offset second_num
	call convert_StringToInt ; передаем в функцию "конвертация строки в число" два параметра: 1) адрес начала буфера строки 2) адрес начала второго числа

ENDM


; начало основной программы
start:
	mov ax, @data
	mov ds, ax
	mov es, ax ; настройка регистров DS, ES на сегмент данных
calc:
	mov ah, 9h
	mov dx, offset carriage_return
	int 21h ; вывод переноса
	
	mov ah, 9h
	mov dx, offset start_menu
	int 21h ; вывод главного меню калькулятора

	check_operation ; выозов макроса для выбора операции

; выбрали операцию суммы
sum:
	input_nums ; вызов макроса для перевода строки в число
	call sum_proc ; вызов процедуры суммы 
	push offset second_num ; передаем в процедуру print смещение числа
    call print 	  ; вызов процедуры для вывода результата на экран
	jmp calc
	
; выбрали операцию разности
diff:
	input_nums ; вызов макроса для перевода строки в число
	call diff_proc
   	push offset first_num ; передаем в процедуру print смещение числа
   	call print	  ; вызов процедуры для вывода результата на экран
	jmp calc

; выбрали операцию произведения
multi:
	input_nums ; вызов макроса для перевода строки в число
	call multi_proc

; выбрали операцию деления
divide:
	input_nums ; вызов макроса для перевода строки в число
	call divide_proc


error_symbol: ; метка для вывода ошибки, когда пользователь введет неверный символ
	mov ah, 9h
	mov dx, offset error_symbol_string
	int 21h
	jmp calc

error_divide0: ; метка для вывода ошибки, когда пользователь решит выполнить деление на 0
	mov ah, 9h
	mov dx, offset error_divide0_string
	int 21h
	jmp calc
	
exit_program: ; метка для выхода из программы
	mov ah, 9h
	mov dx, offset exit_program_string 
	int 21h		; вывыод пользователю, что произошел выход из программы
	
	mov ah,4Ch  
	mov al,00h  
	int 21h     ; снять программу с выполнения


; Процедура для выполнения операции суммы между двумя операндами.
; Процедура полагается на 2 глобальные переменные: 1) first_num - первый операнд 2) second_num - второй операнд
; Не принимает никакие параметры
; Для вызова данной процедуры необходимо предварительно перевести два операнда из строкового типа в числовой
; Портит регистры ax, bx, cx, dx
; Краткая суть: в регстиры ax, bx, cx, dx помещается первое 8 - байтовое число, и с помощью команд add, adc производится сложение со вторым операндом с учетом перенсов.
sum_proc proc 
	mov ax, [first_num]
    mov bx, [first_num+2]
    mov cx, [first_num+4]
    mov dx, [first_num+6]

   	add [second_num], ax
   	adc [second_num+2], bx
   	adc [second_num+4], cx
    adc [second_num+6], dx
	ret
endp

; процедура для выполнения операции разнсти между двумя операндами.
; процедура полагается на 2 глобальные переменные: 1) first_num - первый операнд 2) second_num - второй операнд
; не принимает никакие параметры
; для вызова данной процедуры необходимо предварительно перевести два операнда из строкового типа в числовой
; портит регистры ax, bx, cx, dx
; Краткая суть: в регстиры ax, bx, cx, dx помещается первое 8 - байтовое число, и с помощью команд sub, sbb производится разность со вторым операндом с учетом перенсов.
diff_proc proc 
	mov ax, [second_num]
   	mov bx, [second_num+2]
   	mov cx, [second_num+4]
   	mov dx, [second_num+6]
	
    sub [first_num], ax
    sbb [first_num+2], bx
    sbb [first_num+4], cx
    sbb [first_num+6], dx
	ret
endp

; Процедура для выполнения операции произведения между двумя операндами.
; Процедура полагается на 5 глобальных переменных: 1) first_num - первый операнд 2) second_num - второй операнд 3) zero - константа "0"
; 4) unit - константа "1" 5) count_negNumbers - кол-во отрицательных чисел среди двух операндов
; Не принимает никакие параметры
; Для вызова данной процедуры необходимо предварительно перевести два операнда из строкового типа в числовой
; Портит регистры ax, bx, cx, dx, di
; Краткая суть: сначала идет проверка на 0 операндов, чтоб если что не выполнять алгоритм, а вывести сразу 0. Далее идет алгоритм, в котором первый операнд прибавляется сам к себе
; столько раз, каково значение второго операнда, тем самым реализована операция произведения
multi_proc proc
	mov di, offset first_num  ; кладем в DI смещение первого числа
	fild qword ptr[di] 		  ; загружаем 8-и байтовое число в регистрвый стек сопроцессора
	ficom zero 			      ; проверяем на 0
	fstsw ax 			      ; выгружаем регистр SW (слово состояния) в регистр ax для проверки флага 0
	test ah, 01000000b
	jnz nolik 				  ; если 0 то прыгаем на вывод 0
	
	mov di, offset second_num ; кладем в DI смещение первого числа
	fild qword ptr[di] 		  ; загружаем 8-и байтовое число в регистрвый стек сопроцессора
	ficom zero				  ; проверяем на 0
	fstsw ax 				  ; выгружаем регистр SW (слово состояния) в регистр ax для проверки флага 0
	test ah, 01000000b
	jnz nolik 				  ; если 0 то прыгаем на вывод 0
	
	fisub unit 				  ; вычитаем 1 операцию, так как в first_num уже хранится число
	fistp qword ptr[di] 	  ; кладем значение из регистрвого стека сопрцессора в память
	
	xor ax,ax
	mov di, offset second_num ; в DI кладем смещение второго числа
	mov ax, [first_num] 	  ; загрузка в ax 0-1 байта
    mov bx, [first_num+2]	  ; загрузка в bx 2-3 байта
    mov cx, [first_num+4]	  ; загрузка в cx 4-5 байта
    mov dx, [first_num+6] 	  ; загрузка в dx 6-7 байта
	
test0:
	
	fild qword ptr[di] 		  ; загружаем 8-и байтовое число в регистрвый стек сопроцессора
	ficom zero 				  ; проверяем на 0
	push ax 				  ; сохраняем ax в стеке
	fstsw ax
	test ah, 01000000b 		  ; проверка на 0
	jnz nol 				  ; если ноль, то выводим получнный результат
	fisub unit 				  ; иначе уменьщаем второй операнд
	fistp qword ptr[di] 	  ; кладем обратно в память уменьшенный на 1 второй операнд
	
	pop ax 					  ; возвращаем значение, которое клали в стек
   	add [first_num], ax       ; с помощью команд add, adc производится сложение со вторым операндом с учетом перенсов
   	adc [first_num+2], bx
   	adc [first_num+4], cx
    adc [first_num+6], dx
	jmp test0
	
nol:
	test [count_negNumbers], 1b ; проверяем, если 1 операнд был отрицательным, значит резултат отрицательный и нужно перевести в доп. код
	jz not_neg_mul
	fild qword ptr[first_num]   ; загружаем 8-и байтовое число в регистрвый стек сопроцессора
	fchs 						; перевод числа в дополнительный код
	fistp qword ptr[first_num]  ; кладем обратно в память
not_neg_mul: 
	push offset first_num 		; если отрицательных чисел не было, или же 2 отрицателньых то перевод в доп. код не нужен
	call print 					; вывод результата
	jmp calc
nolik:							; в этой метке выводим 0, если один из операндов оказался 0
	push offset zero_number
	call print ; вывод результата
	jmp calc
	ret
endp

; Процедура для выполнения операции деления между двумя операндами
; Процедура полагается на 6 глобальных переменных: 1) first_num - первый операнд 2) second_num - второй операнд 3) zero - константа "0"
; 4) unit - константа "1" 5) count_negNumbers - кол-во отрицательных чисел среди двух операндов 6) help_num - 8-и байтовое число, в котором хранится результат деления
; Не принимает никакие параметры
; Для вызова данной процедуры необходимо предварительно перевести два операнда из строкового типа в числовой
; Портит регистры ax, bx, cx, dx, di
; Краткая суть: сначала идет проверка на 0 первого, чтоб если что не выполнять алгоритм, а вывести сразу 0. Далее идет проверка на 0 второго операнда
; далее идет алгоритм, в котором первый операнд вычитает из себя второй операнд столько раз, пока первый операнд не станет меньше второго.
divide_proc proc
	mov di, offset second_num ; кладем в DI смещение второго числа
	
	fild qword ptr[di] 		  ; загружаем 8-и байтовое число в регистрвый стек сопроцессора
	ficom zero 				  ; проверяем на 0
	fstsw ax 				  ; выгружаем регистр SW (слово состояния) в регистр ax для проверки флага 0
	
	test ah, 01000000b 		  ; проверка на 0
	jnz error_divide0 		  ; если 0, то вывод ошибки о делении на 0

	mov di, offset first_num  ; кладем в DI смещение первого числа
	
	fild qword ptr[di] 		  ; загружаем 8-и байтовое число в регистрвый стек сопроцессора
	ficom zero 				  ; проверяем на 0
	fstsw ax 				  ; выгружаем регистр SW (слово состояния) в регистр ax для проверки флага 0
	
	test ah, 01000000b  	  ; проверка на 0
	jnz nolik_div			  ; если 0 - то выводим 0

	mov ax, [second_num]	  ; загрузка в ax 0-1 байта
	mov bx, [second_num+2]	  ; загрузка в bx 2-3 байта
	mov cx, [second_num+4]    ; загрузка в cx 4-5 байта
	mov dx, [second_num+6 ]   ; загрузка в dx 6-7 байта

compare:
	cmp [first_num+6], dx	  ; сравниваем поочередно два операнда, сначала старшую часть и так до самой младшей
	JB print_result
	JA substract
	
	cmp [first_num+4], cx
	JB print_result
	JA substract
	
	cmp [first_num+2], bx
	JB print_result
	JA substract
	
	cmp [first_num], ax
	JB print_result
	
substract:					  	; производим вычитание из первого операнда вторго
	sub [first_num], ax
	sbb [first_num+2], bx
	sbb [first_num+4], cx
	sbb [first_num+6], dx
	
	fild qword ptr[help_num]  	; загружаем 8-и байтовое число в регистрвый стек сопроцессора
	fiadd unit			      	; вычитаем 1
	fistp qword ptr[help_num] 	; кладем обратно в память
	jmp compare

print_result: 
	test [count_negNumbers], 1b ; определяем знак результата
	jz not_neg_div
	
	fild qword ptr[help_num] 	; если только 1 операнд отрицательный, то переводим результат в доп. код
	fchs
	fistp qword ptr[help_num]
not_neg_div:
	push offset help_num
	call print
	mov ax, 0b
	mov [help_num], ax 			; отчищаем память для следующего результата деления
	mov [help_num+2], ax
	mov [help_num+4], ax
	mov [help_num+6], ax
	
	jmp calc
nolik_div: 						; метка, если нужно вывести 0
	push offset zero_number
	call print
	jmp calc
ret
endp

; Процедура для конвертации строки в число
; Процедура полагается на 4 глобальных переменных: 1) count_negNumbers - кол-во отрицательных чисел среди двух операндов 2) ten - константа "10" 3) added_num - цифра, которая добавляется при накапливаемости числа
; 4) num_of_operation - номер операции
; Принимает два параметра: 1) ptr_input_num - указатель на буфер введенной строки 2) ptr_num указатель на адрес в памяти, куда запишется число
; Для вызова данной процедуры необходимо предварительно положить в стек буфер и указатель на нужное место для числа
; Портит регистры ax, bx, cx, dx, di, si
; Краткая суть: настраиваем регистр dx на буфер, записываем туда число, настраиваем si на буфер, проверяем на знак минуса, если минус, то увеличиваем count_negNumbers на 1, и поднимаем флаг bx
; Потом переводим число по следующему алгоиртму. Считываем первый символ, умножаем на 10, прибавляем второй символ, снова умножаем на 10 и т.д. пока не закончатся символы. В конце проверяем флаги
; и в зависимости от того, какая операция и какие флаги установлены - реашаем, нужен ли перевод в доп. код. или нет
convert_StringToInt proc PASCAL
ARG ptr_input_num, ptr_num  ; ptr_input_num - указатель на буфер введенной строки, ptr_num указатель на адрес в памяти, куда запишется число
	mov ah,0ah
	mov dx, offset ptr_input_num ; Адрес строки, куда запишется число
	int 21h 

	mov dl,10
	mov ah,02h
	int 21h ; Вывод переноса
	
	mov si, offset ptr_input_num ; настраиваем SI на буфер
	inc si
	inc si						 ; увеличили на 2, т.к 1 байт - макс.длина буфера, 2-байт реальная длина буфера
	cmp byte ptr[si],'-'		 ; проверяем отрицателен ли операнд
	jnz clear_memory
	mov al, [count_negNumbers]
	inc al						 ; если отрицательный то увеличиваем count_negNumbers на 1 (для произведения и деления)
	mov [count_negNumbers], al
	mov bx, 1 				     ; флаг отрицательный ли операнд (для сложения и вычитания)
	inc si


clear_memory:  					 ; отчистка памяти для числа
	mov di, ptr_num
	xor ax, ax
	mov [di], ax
	mov [di+2], ax
	mov [di+4], ax
	mov [di+6], ax
	
convert_CharToInt:
	mov ax, [di] 				; настроили ax на строку где будет храниться INT число
	mov cl, [si] 				; считываем цифру числа
	cmp cl, 0dh 				; проверка на конец буфера
	je check_flag
	cmp cl, 30h					; сравниваем, чтоб код числа был в диапазоне от 30-39
	jc 	error_symbol
	cmp cl, 40h
	jnb error_symbol
	
	fild qword ptr[di]			; загружаем число в регистровый стек сопроцессора
	fimul ten					; умножаем его на 10
	fistp qword ptr[di]			; кладем обратно в память
	sub cl, 30h					; делаем из кода символа саму цифру
	xor ch, ch
	mov added_num, cx
	fild qword ptr[di]			; загружаем число в регистровый стек сопроцессора
	fiadd added_num				; добавляем цифру к умноженной на 10 предыдущей цифре
	fistp qword ptr[di]			; кладем обратно в память
	inc si						; переход к следующему символу
	jmp convert_CharToInt
	
check_flag:
	cmp [num_of_operation], 10b ; если выбрана операция умножения, то не переводить в доп. код
	je exit
	cmp [num_of_operation], 11b ; если выбрана операция деления, то не переводить в доп. код
	je exit
	cmp bx, 1					; если операнд отрицательный (и выбрана команда сложения, разности), то перевести в доп.код
	jnz exit
	fild qword ptr[di]			; загружаем 8-и байтовое число в регистрвый стек сопроцессора
	fchs						; перевод в доп. код
	fistp qword ptr[di]			; кладем обратно в память
exit:
	ret
convert_StringToInt endp


; Процедура для конвертации числа в строку
; Процедура полагается на 2 глобальных переменных: 1) count_negNumbers - кол-во отрицательных чисел среди двух операндов 2) num_of_operation - номер операции
; Принимает один параметр: 1) num_ptr - указатель на память, где лежит число
; Для вызова данной процедуры необходимо предварительно положить в стек 8и байтовое число, которое собираемся выводить
; Портит регистры ax, bx, cx, dx, di, si
; Используется локальную переменную help для временного хранения 8и байтового числа
; Краткая суть: проверяем число на отрицательность, в зависимости от этого сначала выводим или не выводим "-", после этого делим 8и байтовое число на 10 кусками по 2 байта.
; Целую часть записываем каждый раз в те 2 байта, которые мы делили, а остаток в регистр dx. А итоговый остаток 
; после деления последних 2 байт заносим в регистр DX, после чего прибавляем к нему код "0", тем самым получая символ нужной нам цифры.
; Закидываем в стек и повторяем действия пока все 8 байт не окажутся 0-ыми. Полученную строку выводим посимвольно из стека.
print proc PASCAL
ARG num_ptr
	mov ah, 9
	mov dx, offset result
	int 21h
	mov di, num_ptr

	mov ax, [di+6]				; проверяем AX на отрицательность
	test ax, ax
	jns start_cicl

	; Выводим -
	mov cx, ax
	mov ah, 02h
	mov dl, '-' 
	int 21h
	
	fild qword ptr [di]			; загружаем 8-и байтовое число в регистрвый стек сопроцессора
	fchs						; переводим в доп. код
	fistp qword ptr [di]		; возвращаем обратно в память
			
start_cicl:
	mov ax, [di] 				; Записываем число в num_ptr
	
	mov word ptr num_ptr[0], ax
	mov ax, [di+2]
	mov word ptr num_ptr[2], ax
	mov ax, [di+4]
	mov word ptr num_ptr[4], ax
	mov ax, [di+6]
	mov word ptr num_ptr[6], ax
	 
	mov bx, 10      			; 10 - делитель
	mov di, 0       			; тут хранится кол-во цифр
next_digit:
	mov cx, 4       			; кладем 4 повторения в цикл, чтобы пройти 4 раза по 2 байта все слово
	mov si, 6       			; Начальное смещение делимого
	mov dx, 0       			; остаток от предыдущего деления
div_by_10:
	mov ax, word ptr num_ptr[si]; кладем в ax 2 байта
	div bx						; делим
	mov word ptr num_ptr[si], ax; целую часть кладем обратно в те же 2 байта, остаток находится в DX
	sub si, 2					; смещаемся на следующие 2 байта
	loop div_by_10

	add dl, '0'					; преобразование в символ
	push dx              		; Сохранение символа в стеке

	inc di             
	 
	mov ax, word ptr num_ptr[0] ; проверка все ли число 0
	or  ax, word ptr num_ptr[2]
	or  ax, word ptr num_ptr[4]
	or  ax, word ptr num_ptr[6]
	jnz next_digit  
	 
	mov cx, di      			; выводим пока есть цифры
	mov ah, 02h 
show_digit:
	pop dx
	int 21h             		; вывод символа на экран
	loop show_digit
	 
	mov [count_negNumbers], 0	; отчищаем переменные для следующей операции
	mov [num_of_operation], 0
	ret
print endp
	
end